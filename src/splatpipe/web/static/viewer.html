<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Splatpipe Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a1a;
           font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #header {
      position: absolute; top: 0; left: 0; right: 0; z-index: 10;
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 20px; pointer-events: none;
      background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
    }
    #header > * { pointer-events: auto; }
    #title { color: #fff; }
    #title h1 { font-size: 18px; font-weight: 600; }
    #title p { font-size: 12px; color: #aaa; margin-top: 2px; }
    #quality-buttons { display: flex; gap: 6px; align-items: center; }
    .quality-btn {
      padding: 8px 16px; border: 1px solid rgba(255,255,255,0.3);
      border-radius: 6px; background: rgba(0,0,0,0.5); color: #ccc;
      font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s;
    }
    .quality-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    .quality-btn.active {
      background: rgba(255,255,255,0.25); color: #fff;
      border-color: rgba(255,255,255,0.6); font-weight: 700;
    }
    #stats {
      position: absolute; bottom: 0; left: 0; right: 0; z-index: 10;
      text-align: center; padding: 16px; pointer-events: none;
      background: linear-gradient(0deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
    }
    #splat-count {
      font-size: 28px; font-weight: 300; color: #fff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.8);
    }
    #debug-panel {
      position: absolute; top: 60px; right: 20px; z-index: 10;
      background: rgba(0,0,0,0.6); border-radius: 8px;
      padding: 10px 14px; color: #ccc; font-size: 12px;
    }
    #debug-panel label {
      display: flex; align-items: center; gap: 6px; cursor: pointer; margin: 4px 0;
    }
    #debug-panel input[type="checkbox"] { cursor: pointer; }
    #loading {
      position: absolute; inset: 0; z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: #1a1a1a; transition: opacity 0.5s;
    }
    #loading.hidden { opacity: 0; pointer-events: none; }
    #loading p { color: #aaa; font-size: 16px; margin-top: 16px; }
    .spinner {
      width: 40px; height: 40px;
      border: 3px solid rgba(255,255,255,0.1); border-top-color: #fff;
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #controls-hint {
      position: absolute; bottom: 60px; left: 20px; z-index: 10;
      color: rgba(255,255,255,0.4); font-size: 11px; pointer-events: none;
    }
    #annotation-markers { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 15; }
    .ann-marker { position: absolute; transform: translate(-50%, -100%); pointer-events: auto; cursor: pointer; transition: opacity 0.2s; }
    .ann-dot {
      width: 28px; height: 28px; border-radius: 50%; background: #ff6b35; color: white;
      display: flex; align-items: center; justify-content: center; font-size: 13px;
      font-weight: 700; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .ann-tooltip {
      display: none; position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.9); color: white; padding: 8px 12px; border-radius: 8px;
      white-space: nowrap; font-size: 12px; line-height: 1.4; max-width: 200px; pointer-events: none;
    }
    .ann-tooltip h4 { font-weight: 600; margin: 0 0 2px; }
    .ann-tooltip p { margin: 0; opacity: 0.8; white-space: normal; }
    .ann-marker:hover .ann-tooltip { display: block; }
  </style>
</head>
<body>
  <canvas id="app-canvas"></canvas>

  <div id="header">
    <div id="title">
      <h1>Splatpipe Viewer</h1>
      <p>Splatpipe Viewer</p>
    </div>
    <div id="quality-buttons">
      <button class="quality-btn" data-preset="low">Low</button>
      <button class="quality-btn" data-preset="medium">Medium</button>
      <button class="quality-btn" data-preset="high">High</button>
      <button class="quality-btn" data-preset="ultra">Ultra</button>
      <select id="splat-budget" class="quality-btn" style="appearance:auto">
        <option value="0">No limit</option>
        <option value="1000000">1M</option>
        <option value="2000000">2M</option>
        <option value="3000000">3M</option>
        <option value="4000000">4M</option>
        <option value="6000000">6M</option>
      </select>
    </div>
  </div>

  <div id="debug-panel">
    <label><input type="checkbox" id="debug-lod"> Colorize LOD</label>
    <label><input type="checkbox" id="debug-sh"> Colorize SH updates</label>
  </div>

  <div id="stats">
    <div id="splat-count">Splats: 0.00M</div>
  </div>

  <div id="controls-hint">
    WASD / Arrow keys to move &middot; Mouse drag to look &middot; Scroll to zoom &middot; Shift for fast
  </div>

  <div id="loading">
    <div class="spinner"></div>
    <p>Loading splats...</p>
  </div>

  <div id="annotation-markers"></div>

  <script type="importmap">
  {
    "imports": {
      "playcanvas": "https://cdn.jsdelivr.net/npm/playcanvas@2.16/+esm"
    }
  }
  </script>
  <script type="module">
  import * as pc from 'playcanvas';

  const CAMERA_CONTROLS_URL =
    'https://cdn.jsdelivr.net/npm/playcanvas/scripts/esm/camera-controls.mjs';
  const { CameraControls } = await import(CAMERA_CONTROLS_URL);

  const canvas = document.getElementById('app-canvas');
  window.focus();

  const SPLAT_URL = 'lod-meta.json';

  const gfxOptions = { deviceTypes: ['webgpu', 'webgl2'], antialias: false };
  const device = await pc.createGraphicsDevice(canvas, gfxOptions);
  const createOptions = new pc.AppOptions();
  createOptions.graphicsDevice = device;
  createOptions.mouse = new pc.Mouse(document.body);
  createOptions.touch = new pc.TouchDevice(document.body);
  createOptions.keyboard = new pc.Keyboard(document.body);
  createOptions.componentSystems = [
    pc.RenderComponentSystem, pc.CameraComponentSystem,
    pc.LightComponentSystem, pc.ScriptComponentSystem,
    pc.GSplatComponentSystem,
    pc.SoundComponentSystem, pc.AudioListenerComponentSystem
  ];
  createOptions.resourceHandlers = [
    pc.TextureHandler, pc.ContainerHandler,
    pc.ScriptHandler, pc.GSplatHandler, pc.AudioHandler
  ];

  const app = new pc.AppBase(canvas);
  app.init(createOptions);
  app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
  app.setCanvasResolution(pc.RESOLUTION_AUTO);

  const dpr = window.devicePixelRatio || 1;
  device.maxPixelRatio = dpr >= 2 ? dpr * 0.5 : dpr;

  const onResize = () => app.resizeCanvas();
  window.addEventListener('resize', onResize);
  app.on('destroy', () => window.removeEventListener('resize', onResize));

  const splatAsset = new pc.Asset('gsplat', 'gsplat', { url: SPLAT_URL });
  app.assets.add(splatAsset);
  await new Promise((resolve, reject) => {
    splatAsset.on('load', resolve);
    splatAsset.on('error', err => reject(new Error(err)));
    app.assets.load(splatAsset);
  });

  // --- Load viewer config ---
  const _DEFAULTS = {
    camera: { pitch_min: -89, pitch_max: 89, zoom_min: 1, zoom_max: 200,
              ground_height: 0.3, bounds_radius: 150 },
    splat_budget: 0,
    annotations: [],
    background: { type: 'color', color: '#1a1a1a' },
    postprocessing: { tonemapping: 'neutral', exposure: 1.5,
                      bloom: false, vignette: false },
    audio: []
  };
  let viewerConfig = _DEFAULTS;
  try {
    const cfgResp = await fetch('viewer-config.json');
    if (cfgResp.ok) viewerConfig = { ..._DEFAULTS, ...await cfgResp.json() };
  } catch (e) { /* use defaults */ }

  app.start();

  // --- Apply post-processing from config ---
  const pp = viewerConfig.postprocessing || _DEFAULTS.postprocessing;
  app.scene.exposure = pp.exposure ?? 1.5;

  const TONEMAP = {
    linear: pc.TONEMAP_LINEAR, neutral: pc.TONEMAP_NEUTRAL,
    aces: pc.TONEMAP_ACES, aces2: pc.TONEMAP_ACES2, filmic: pc.TONEMAP_FILMIC
  };

  app.scene.gsplat.lodUpdateAngle = 90;
  app.scene.gsplat.lodBehindPenalty = 2;
  app.scene.gsplat.radialSorting = true;
  app.scene.gsplat.lodUpdateDistance = 1;
  app.scene.gsplat.lodUnderfillLimit = 10;
  app.scene.gsplat.colorUpdateDistance = 1;
  app.scene.gsplat.colorUpdateAngle = 4;
  app.scene.gsplat.colorUpdateDistanceLodScale = 2;
  app.scene.gsplat.colorUpdateAngleLodScale = 2;

  const splatEntity = new pc.Entity('splat');
  splatEntity.addComponent('gsplat', { asset: splatAsset, unified: true });
  splatEntity.setLocalEulerAngles(180, 0, 0);
  app.root.addChild(splatEntity);
  const gs = splatEntity.gsplat;

  const focusPoint = new pc.Vec3(0, 1, 0);
  const camera = new pc.Entity('camera');
  camera.addComponent('camera', {
    clearColor: new pc.Color(0.15, 0.15, 0.15),
    fov: 75,
    toneMapping: TONEMAP[pp.tonemapping] ?? pc.TONEMAP_NEUTRAL
  });

  // --- Apply background from config ---
  const bg = viewerConfig.background || _DEFAULTS.background;
  if (bg.type === 'color' && bg.color) {
    camera.camera.clearColor = new pc.Color().fromString(bg.color);
    document.body.style.background = bg.color;
  }

  camera.setLocalPosition(0, 2, -10);
  app.root.addChild(camera);
  camera.addComponent('script');
  camera.addComponent('audiolistener');
  const cc = camera.script.create(CameraControls);
  Object.assign(cc, {
    sceneSize: 500,
    moveSpeed: 4,
    moveFastSpeed: 15,
    enableOrbit: true,
    enablePan: true,
    focusPoint: focusPoint
  });

  // --- Apply camera constraints from config ---
  const cam = viewerConfig.camera || _DEFAULTS.camera;
  cc.pitchRange = new pc.Vec2(cam.pitch_min, cam.pitch_max);
  cc.zoomRange = new pc.Vec2(cam.zoom_min, cam.zoom_max);

  const buttons = document.querySelectorAll('.quality-btn');
  const isMobile = pc.platform.mobile;
  let currentPreset = isMobile ? 'medium' : 'high';

  function applyPreset(name) {
    currentPreset = name;
    buttons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.preset === name);
    });
  }

  buttons.forEach(btn => {
    btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
  });
  applyPreset(currentPreset);

  // --- Splat budget from config ---
  const budgetEl = document.getElementById('splat-budget');
  const cfgBudget = viewerConfig.splat_budget || 0;
  if (cfgBudget > 0) {
    if (!budgetEl.querySelector('option[value="' + cfgBudget + '"]')) {
      const opt = document.createElement('option');
      opt.value = String(cfgBudget);
      opt.textContent = (cfgBudget / 1_000_000).toFixed(1) + 'M';
      budgetEl.appendChild(opt);
    }
    budgetEl.value = String(cfgBudget);
  } else {
    budgetEl.value = isMobile ? '1000000' : '4000000';
  }
  app.scene.gsplat.splatBudget = parseInt(budgetEl.value);
  budgetEl.addEventListener('change', () => {
    app.scene.gsplat.splatBudget = parseInt(budgetEl.value);
  });

  document.getElementById('debug-lod').addEventListener('change', e => {
    app.scene.gsplat.colorizeLod = e.target.checked;
  });
  document.getElementById('debug-sh').addEventListener('change', e => {
    app.scene.gsplat.colorizeColorUpdate = e.target.checked;
  });

  document.getElementById('loading').classList.add('hidden');

  // --- Annotation markers ---
  const annotationsData = viewerConfig.annotations || [];
  const markersContainer = document.getElementById('annotation-markers');
  const markerEls = [];
  annotationsData.forEach((ann, i) => {
    const marker = document.createElement('div');
    marker.className = 'ann-marker';
    const label = (ann.label || String(i + 1)).replace(/</g, '&lt;');
    const title = (ann.title || '').replace(/</g, '&lt;');
    const text = (ann.text || '').replace(/</g, '&lt;');
    marker.innerHTML = '<div class="ann-dot">' + label + '</div><div class="ann-tooltip">' +
      (title ? '<h4>' + title + '</h4>' : '') + (text ? '<p>' + text + '</p>' : '') + '</div>';
    markersContainer.appendChild(marker);
    markerEls.push({ el: marker, pos: new pc.Vec3(ann.pos[0], ann.pos[1], ann.pos[2]) });
  });

  const splatCountEl = document.getElementById('splat-count');
  // Pre-allocate reusable vectors outside the frame loop to avoid GC stutter
  const _sp = new pc.Vec3();
  const _tp = new pc.Vec3();
  const _camPos = new pc.Vec3();
  app.on('update', () => {
    const displayed = app.stats.frame.gsplats || 0;
    const displayedM = (displayed / 1_000_000).toFixed(2);
    splatCountEl.textContent = 'Splats: ' + displayedM + 'M';
    // Clamp camera position: ground + bounds
    const pos = camera.getLocalPosition();
    const cx = pc.math.clamp(pos.x, -cam.bounds_radius, cam.bounds_radius);
    const cy = Math.max(pos.y, cam.ground_height);
    const cz = pc.math.clamp(pos.z, -cam.bounds_radius, cam.bounds_radius);
    if (cx !== pos.x || cy !== pos.y || cz !== pos.z) {
      camera.setLocalPosition(cx, cy, cz);
    }
    // Update annotation marker screen positions
    _camPos.copy(camera.getPosition());
    markerEls.forEach(m => {
      camera.camera.worldToScreen(m.pos, _sp);
      _tp.sub2(m.pos, _camPos);
      if (_tp.dot(camera.forward) < 0) {
        m.el.style.display = 'none';
      } else {
        m.el.style.display = '';
        m.el.style.left = _sp.x + 'px';
        m.el.style.top = _sp.y + 'px';
      }
    });
  });

  // --- Audio sources from config ---
  (viewerConfig.audio || []).forEach(src => {
    const audioAsset = new pc.Asset('audio', 'audio', { url: src.file });
    app.assets.add(audioAsset);
    app.assets.load(audioAsset);
    audioAsset.on('load', () => {
      const ent = new pc.Entity('audio-source');
      ent.addComponent('sound', {
        positional: src.positional ?? false,
        volume: src.volume ?? 0.5,
        refDistance: 5, maxDistance: 100
      });
      ent.sound.addSlot('main', { asset: audioAsset, loop: src.loop ?? true, autoPlay: true });
      if (src.pos) ent.setLocalPosition(src.pos[0], src.pos[1], src.pos[2]);
      app.root.addChild(ent);
      ent.sound.play('main');
    });
  });
  </script>
</body>
</html>
